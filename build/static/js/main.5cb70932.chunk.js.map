{"version":3,"sources":["apps/photography/store/tags/selectors.js","apps/photography/store/tags/actions.js","apps/photography/store/tags/constants.js","apps/photography/store/tags/index.js","apps/photography/store/photos/constants.js","apps/AsyncLoader.js","apps/portfolio/index.js","apps/photography/store/configureStore.js","apps/photography/index.js","serviceWorker.js","index.js","apps/photography/store/photos/selectors.js","apps/photography/store/photos/actions.js","apps/photography/store/photos/index.js","apps/photography/store/filters/constants.js","apps/photography/store/filters/selectors.js","apps/photography/store/filters/actions.js","apps/photography/store/filters/index.js","apps/photography/helpers/parseForTags.js","apps/photography/helpers/getAllUniqueValuesOf.js","apps/photography/helpers/parseForFilterOptions.js","apps/photography/helpers/index.js"],"names":["getAllTags","state","tags","getAllSelectedTags","reduce","acc","tag","isSelected","push","id","toggleTagSelected","tagId","dispatch","getState","type","photos","getAllPhotos","initialState","__webpack_exports__","arguments","length","undefined","action","FETCH_PHOTOS_SUCCESS","parseForTags","payload","map","Object","assign","selectedTags","includes","objectSpread","isEnabled","find","photo","every","t","__webpack_require__","d","SET_OPEN_PHOTO","CLOSE_OPEN_PHOTO","AsyncLoader","opts","Loadable","loading","react_default","a","createElement","AsyncPortfolio","loader","e","then","bind","modules","createStoreWithMiddleware","composeWithDevTools","applyMiddleware","ReduxThunk","createStore","rootReducer","combineReducers","photosReducer","tagsReducer","filters","filtersReducer","devStore","store","configureStore","window","REDUX_STATE","AsyncPhotography","Promise","all","App","es","Component","Boolean","location","hostname","match","AppBundle","react_router_dom","react_router","exact","path","component","onload","preloadReady","ReactDOM","hydrate","document","getElementById","navigator","serviceWorker","ready","registration","unregister","getPhoto","props","filter","getOpenPhoto","createSelector","album","medium","subject","openPhoto","setOpenPhoto","public_id","url","closeOpenPhoto","error","FILTER_IDS","getAllFilterOptions","getAllSelectedFilters","options","selectedOption","option","toggleSelectedFilter","title","parseForFilterOptions","concat","a2","o","getAllUniqueValuesOf","values","i","context","custom","val","indexOf","filterOptions","helpers_parseForTags","helpers_getAllUniqueValuesOf","helpers_parseForFilterOptions"],"mappings":"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","file":"static/js/main.5cb70932.chunk.js","sourcesContent":["export const getAllTags = state => state.tags;\n\nexport const getTag = (state, props) =>\n  state.tags.filter(tag => tag.id === props.id);\n\nexport const getAllSelectedTags = tags => {\n  return tags.reduce((acc, tag) => {\n    if (tag.isSelected) {\n      acc.push(tag.id);\n    }\n    return acc;\n  }, []);\n};\n\n// export const isTagSelected = createSelector(\n//   getTag,\n//   tag => tag && tag.isSelected\n// );\n\n// export const isTagEnabled = createSelector(getTag, tag => tag && tag.isEnabled);\n","import { TOGGLE_TAG_SELECTED, TOGGLE_ENABLED_TAGS } from \"./constants\";\nimport { getAllPhotos } from \"../photos\";\n\nexport const toggleTagSelected = tagId => (dispatch, getState) => {\n  dispatch({\n    type: TOGGLE_TAG_SELECTED,\n    id: tagId\n  });\n  const photos = getAllPhotos(getState());\n  dispatch({ type: TOGGLE_ENABLED_TAGS, photos });\n};\n","export const TOGGLE_TAG_SELECTED = \"TOGGLE_TAG_SELECTED\";\nexport const TOGGLE_ENABLED_TAGS = \"TOGGLE_TAG_ENABLED\";\nexport const FETCH_TAGS = \"FETCH_TAGS\";\n","import { parseForTags } from \"../../helpers\";\nimport { FETCH_PHOTOS_SUCCESS } from \"../photos\";\nimport { TOGGLE_TAG_SELECTED, TOGGLE_ENABLED_TAGS } from \"./constants\";\nimport { getAllSelectedTags } from \"./selectors\";\nexport { getAllTags, getTag, getAllSelectedTags } from \"./selectors\";\nexport { toggleTagSelected } from \"./actions\";\n\nconst initialState = [];\n\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case FETCH_PHOTOS_SUCCESS:\n      return parseForTags(action.payload.photos);\n    case TOGGLE_TAG_SELECTED:\n      return state.map(tag => {\n        if (tag.id !== action.id) {\n          return tag;\n        }\n\n        return Object.assign({}, tag, {\n          isSelected: !tag.isSelected\n        });\n      });\n    case TOGGLE_ENABLED_TAGS:\n      const selectedTags = getAllSelectedTags(state);\n      const result = state.map(tag => {\n        if (!selectedTags.length || selectedTags.includes(tag.id)) {\n          return { ...tag, isEnabled: true };\n        }\n        if (\n          action.photos.find(\n            photo =>\n              photo.tags.includes(tag.id) &&\n              selectedTags.every(t => photo.tags.includes(t))\n          )\n        ) {\n          return { ...tag, isEnabled: true };\n        }\n        return { ...tag, isEnabled: false };\n      });\n      return result;\n    default:\n      return state;\n  }\n};\n","export const FETCH_PHOTOS_SUCCESS = \"FETCH_PHOTOS_SUCCESS\";\nexport const SET_OPEN_PHOTO = \"SET_OPEN_PHOTO\";\nexport const CLOSE_OPEN_PHOTO = \"CLOSE_OPEN_PHOTO\";\n","import React from \"react\";\nimport Loadable from \"react-loadable\";\n\nconst AsyncLoader = opts =>\n  Loadable({\n    loading: () => <div>loading...</div>,\n    ...opts\n  });\n\nexport default AsyncLoader;\n","import AsyncLoader from \"../AsyncLoader\";\n\nconst AsyncPortfolio = AsyncLoader({\n  loader: () => import(/* webpackChunkName: \"home\" */ \"./App\"),\n  modules: [\"home\"]\n});\n\nexport default AsyncPortfolio;\n","import { createStore, combineReducers, applyMiddleware } from \"redux\";\nimport { composeWithDevTools } from \"redux-devtools-extension\";\nimport ReduxThunk from \"redux-thunk\";\nimport photosReducer from \"./photos\";\nimport tagsReducer from \"./tags\";\nimport filtersReducer from \"./filters\";\n\nconst createStoreWithMiddleware = composeWithDevTools(\n  applyMiddleware(ReduxThunk)\n)(createStore);\n\nconst rootReducer = combineReducers({\n  photos: photosReducer,\n  tags: tagsReducer,\n  filters: filtersReducer\n});\n\nexport default function configureStore(initialState = {}) {\n  return createStoreWithMiddleware(rootReducer, initialState);\n}\n","import React, { Component } from \"react\";\nimport { Provider as ReduxProvider } from \"react-redux\";\nimport AsyncLoader from \"../AsyncLoader\";\nimport configureStore from \"./store/configureStore\";\nimport dummyStore from \"./dummyStore.json\";\n\nconst devStore = process.env.NODE_ENV === \"development\" ? dummyStore : {};\nconst store = configureStore(window.REDUX_STATE || devStore || {});\n\nconst AsyncPhotography = AsyncLoader({\n  loader: () => import(/* webpackChunkName: \"photography\" */ \"./Photography\"),\n  modules: [\"photography\"]\n});\n\nclass App extends Component {\n  render() {\n    return (\n      <ReduxProvider store={store}>\n        <AsyncPhotography />\n      </ReduxProvider>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import \"@babel/polyfill\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Loadable from \"react-loadable\";\nimport { BrowserRouter as Router, Route } from \"react-router-dom\";\nimport AsyncPortfolio from \"./apps/portfolio\";\nimport AsyncPhotography from \"./apps/photography\";\nimport \"./global.css\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst AppBundle = (\n  <Router>\n    <Route exact path=\"/\" component={AsyncPortfolio} />\n    <Route path=\"/photography\" component={AsyncPhotography} />\n  </Router>\n);\n\nwindow.onload = () => {\n  Loadable.preloadReady().then(() => {\n    ReactDOM.hydrate(AppBundle, document.getElementById(\"root\"));\n  });\n};\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { createSelector } from \"reselect\";\n\nexport const getAllPhotos = state => state.photos.photos;\n\nexport const getPhoto = (state, props) =>\n  state.photos.photos.filter(photo => photo.id === props.id);\n\nexport const getPhotoTags = createSelector(\n  getPhoto,\n  photo => photo && photo.tags\n);\n\nexport const getPhotoAlbum = createSelector(\n  getPhoto,\n  photo => photo && photo.album\n);\n\nexport const getPhotoMedium = createSelector(\n  getPhoto,\n  photo => photo && photo.medium\n);\n\nexport const getPhotoSubject = createSelector(\n  getPhoto,\n  photo => photo && photo.subject\n);\n\nexport const getOpenPhoto = state => state.photos.openPhoto;\n","import axios from \"axios\";\nimport {\n  FETCH_PHOTOS_SUCCESS,\n  SET_OPEN_PHOTO,\n  CLOSE_OPEN_PHOTO\n} from \"./constants\";\n\nexport const fetchAllPhotos = url => dispatch => {\n  console.log(\"Fetch: \", url);\n  let photos = [];\n\n  const fetchPhotos = url =>\n    axios\n      .get(url)\n      .then(handleErrors)\n      .then(({ data }) => {\n        photos = photos.concat(data.resources);\n        if (data.next_cursor) {\n          const urlParams = new URLSearchParams(url);\n          urlParams.set(\"next_cursor\", data.next_cursor);\n          return fetchPhotos(decodeURIComponent(urlParams.toString()));\n        } else {\n          dispatch(fetchPhotosSuccess(photos));\n          return photos;\n        }\n      })\n      .catch(error => {\n        console.log(\"Failed to fetch photos\", error);\n      });\n\n  return fetchPhotos(url);\n};\n\nconst handleErrors = response => {\n  if (!responseOk(response.status)) {\n    throw Error(`${response.status}: ${response.statusText}`);\n  }\n  return response;\n};\n\nconst responseOk = n => (n >= 200 && n < 300 ? true : false);\n\nconst fetchPhotosSuccess = photos => ({\n  type: FETCH_PHOTOS_SUCCESS,\n  payload: { photos }\n});\n\nexport const setOpenPhoto = (public_id, url) => dispatch => {\n  dispatch({\n    type: SET_OPEN_PHOTO,\n    public_id,\n    url\n  });\n};\n\nexport const closeOpenPhoto = () => dispatch => {\n  dispatch({\n    type: CLOSE_OPEN_PHOTO\n  });\n};\n","import {\n  FETCH_PHOTOS_SUCCESS,\n  SET_OPEN_PHOTO,\n  CLOSE_OPEN_PHOTO\n} from \"./constants\";\nexport {\n  FETCH_PHOTOS_SUCCESS,\n  SET_OPEN_PHOTO,\n  CLOSE_OPEN_PHOTO\n} from \"./constants\";\n\nexport {\n  getAllPhotos,\n  getPhoto,\n  getPhotoTags,\n  getPhotoAlbum,\n  getPhotoMedium,\n  getPhotoSubject,\n  getOpenPhoto\n} from \"./selectors\";\nexport { fetchAllPhotos, setOpenPhoto, closeOpenPhoto } from \"./actions\";\n\nconst initialState = {\n  photos: [],\n  openPhoto: null,\n  error: null\n};\n\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case FETCH_PHOTOS_SUCCESS:\n      return {\n        ...state,\n        photos: action.payload.photos\n      };\n    case SET_OPEN_PHOTO:\n      return {\n        ...state,\n        openPhoto: {\n          public_id: action.public_id,\n          url: action.url\n        }\n      };\n    case CLOSE_OPEN_PHOTO:\n      return {\n        ...state,\n        openPhoto: null\n      };\n    default:\n      return state;\n  }\n};\n","export const FILTER_IDS = [\"category\", \"medium\", \"subject\", \"location\"];\nexport const TOGGLE_SELECTED_FILTER = \"TOGGLE_SELECTED_FILTER\";\n","export const getAllFilterOptions = state => state.filters;\n\nexport const getFilter = (state, id) => {\n  return state.filters.filter(filter => filter.id === id);\n};\n\nexport const getAllSelectedFilters = state => {\n  return state.filters.reduce((acc, filter) => {\n    if (filter && filter.options.length) {\n      const selectedOption = filter.options.filter(\n        option => option.isSelected === true\n      );\n\n      if (selectedOption.length) {\n        acc[filter.id] = selectedOption[0].id;\n      }\n    }\n    return acc;\n  }, {});\n};\n","import { TOGGLE_SELECTED_FILTER } from \"./constants\";\n\nexport const toggleSelectedFilter = (title, option) => dispatch => {\n  dispatch({\n    type: TOGGLE_SELECTED_FILTER,\n    title,\n    option\n  });\n};\n","import { FETCH_PHOTOS_SUCCESS } from \"../photos/constants\";\nimport { parseForFilterOptions } from \"../../helpers\";\nimport { TOGGLE_SELECTED_FILTER } from \"./constants\";\nexport { FILTER_IDS, TOGGLE_SELECTED_FILTER } from \"./constants\";\nexport { getAllFilterOptions, getAllSelectedFilters } from \"./selectors\";\nexport { toggleSelectedFilter } from \"./actions\";\n\nconst initialState = [];\n\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case FETCH_PHOTOS_SUCCESS:\n      return parseForFilterOptions(action.payload.photos);\n    case TOGGLE_SELECTED_FILTER:\n      return state.map(filter => {\n        if (filter.id !== action.title) {\n          return filter;\n        }\n\n        return {\n          ...filter,\n          options: filter.options.map(option => {\n            if (option.id !== action.option) {\n              return Object.assign({}, option, {\n                isSelected: false\n              });\n            }\n\n            return Object.assign({}, option, {\n              isSelected: !option.isSelected\n            });\n          })\n        };\n      });\n    default:\n      return state;\n  }\n};\n","const parseForTags = photos => {\n  if (!photos) {\n    return;\n  }\n\n  return photos.reduce((a, photo) => {\n    return a.concat(\n      photo.tags.reduce((a2, tag) => {\n        if (tag && (!a.length || a.filter(o => o.id === tag).length === 0)) {\n          a2.push({\n            id: tag,\n            isEnabled: true,\n            isSelected: false\n          });\n        }\n\n        return a2;\n      }, [])\n    );\n  }, []);\n};\n\nexport default parseForTags;\n","const getAllUniqueValuesOf = (photos, id) => {\n  let values = [];\n  for (let i = 0; i < photos.length; i++) {\n    const photo = photos[i];\n    if (!photo.context || !photo.context.custom || !photo.context.custom[id]) {\n      continue;\n    }\n\n    const val = photo.context.custom[id];\n    if (values.indexOf(val) === -1) {\n      values.push(val);\n    }\n  }\n  return values;\n};\n\nexport default getAllUniqueValuesOf;\n","import { FILTER_IDS } from \"../store/filters\";\nimport { getAllUniqueValuesOf } from \".\";\n\nconst parseForFilterOptions = photos => {\n  const filterOptions = [];\n\n  FILTER_IDS.map(id => {\n    const options = getAllUniqueValuesOf(photos, id);\n    return filterOptions.push({\n      id,\n      options: options.map(option => {\n        return {\n          id: option,\n          isSelected: false\n        };\n      })\n    });\n  });\n\n  return filterOptions;\n};\n\nexport default parseForFilterOptions;\n","export { default as parseForTags } from \"./parseForTags\";\nexport { default as getEnabledTags } from \"./getEnabledTags\";\nexport { default as getTaggedPhotos } from \"./getTaggedPhotos\";\nexport { default as getAllUniqueValuesOf } from \"./getAllUniqueValuesOf\";\nexport { default as getFilteredPhotos } from \"./getFilteredPhotos\";\nexport { default as parseForFilterOptions } from \"./parseForFilterOptions\";\n"],"sourceRoot":""}